// !!! DO NOT EDIT !!!
// All manual changes will be lost!
// Autogenerated by build.rs

use std::convert::TryFrom;

use crate::error::Error;
use crate::interpreter::Interpreter;
use crate::value::{BuiltinFunction, Value, ValueType};

/// `count_ones(u64) -> u32`
fn f_count_ones(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u32 = u64::count_ones(a0_conv);
        interp.data.push(Value::Integer(u64::from(r)));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `count_zeros(u64) -> u32`
fn f_count_zeros(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u32 = u64::count_zeros(a0_conv);
        interp.data.push(Value::Integer(u64::from(r)));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `leading_zeros(u64) -> u32`
fn f_leading_zeros(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u32 = u64::leading_zeros(a0_conv);
        interp.data.push(Value::Integer(u64::from(r)));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `trailing_zeros(u64) -> u32`
fn f_trailing_zeros(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u32 = u64::trailing_zeros(a0_conv);
        interp.data.push(Value::Integer(u64::from(r)));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `rotate_left(u64, u32) -> u64`
fn f_rotate_left(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: u64 = u64::rotate_left(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `rotate_right(u64, u32) -> u64`
fn f_rotate_right(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: u64 = u64::rotate_right(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `swap_bytes(u64) -> u64`
fn f_swap_bytes(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u64 = u64::swap_bytes(a0_conv);
        interp.data.push(Value::Integer(r));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `reverse_bits(u64) -> u64`
fn f_reverse_bits(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u64 = u64::reverse_bits(a0_conv);
        interp.data.push(Value::Integer(r));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_add(u64, u64) -> Option<u64>`
fn f_checked_add(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_add(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_sub(u64, u64) -> Option<u64>`
fn f_checked_sub(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_sub(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_mul(u64, u64) -> Option<u64>`
fn f_checked_mul(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_mul(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_div(u64, u64) -> Option<u64>`
fn f_checked_div(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_div(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_div_euc(u64, u64) -> Option<u64>`
fn f_checked_div_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_div_euc(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_rem(u64, u64) -> Option<u64>`
fn f_checked_rem(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_rem(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_mod_euc(u64, u64) -> Option<u64>`
fn f_checked_mod_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: Option<u64> = u64::checked_mod_euc(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_neg(u64) -> Option<u64>`
fn f_checked_neg(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: Option<u64> = u64::checked_neg(a0_conv);
        if let Some(v) = r {
            interp.data.push(Value::Integer(v));
        }
        interp.data.push(Value::Boolean(r.is_some()));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_shl(u64, u32) -> Option<u64>`
fn f_checked_shl(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: Option<u64> = u64::checked_shl(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_shr(u64, u32) -> Option<u64>`
fn f_checked_shr(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: Option<u64> = u64::checked_shr(a0_conv, a1_conv);
            if let Some(v) = r {
                interp.data.push(Value::Integer(v));
            }
            interp.data.push(Value::Boolean(r.is_some()));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `saturating_add(u64, u64) -> u64`
fn f_saturating_add(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::saturating_add(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `saturating_sub(u64, u64) -> u64`
fn f_saturating_sub(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::saturating_sub(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `saturating_mul(u64, u64) -> u64`
fn f_saturating_mul(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::saturating_mul(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `saturating_pow(u64, u32) -> u64`
fn f_saturating_pow(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: u64 = u64::saturating_pow(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_add(u64, u64) -> u64`
fn f_wrapping_add(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_add(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_sub(u64, u64) -> u64`
fn f_wrapping_sub(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_sub(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_mul(u64, u64) -> u64`
fn f_wrapping_mul(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_mul(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_div(u64, u64) -> u64`
fn f_wrapping_div(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_div(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_div_euc(u64, u64) -> u64`
fn f_wrapping_div_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_div_euc(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_rem(u64, u64) -> u64`
fn f_wrapping_rem(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_rem(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_mod_euc(u64, u64) -> u64`
fn f_wrapping_mod_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::wrapping_mod_euc(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_neg(u64) -> u64`
fn f_wrapping_neg(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u64 = u64::wrapping_neg(a0_conv);
        interp.data.push(Value::Integer(r));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_shl(u64, u32) -> u64`
fn f_wrapping_shl(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: u64 = u64::wrapping_shl(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_shr(u64, u32) -> u64`
fn f_wrapping_shr(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: u64 = u64::wrapping_shr(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_add(u64, u64) -> (u64, bool)`
fn f_overflowing_add(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_add(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_sub(u64, u64) -> (u64, bool)`
fn f_overflowing_sub(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_sub(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_mul(u64, u64) -> (u64, bool)`
fn f_overflowing_mul(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_mul(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_div(u64, u64) -> (u64, bool)`
fn f_overflowing_div(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_div(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_div_euc(u64, u64) -> (u64, bool)`
fn f_overflowing_div_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_div_euc(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_rem(u64, u64) -> (u64, bool)`
fn f_overflowing_rem(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_rem(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_mod_euc(u64, u64) -> (u64, bool)`
fn f_overflowing_mod_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: (u64, bool) = u64::overflowing_mod_euc(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_neg(u64) -> (u64, bool)`
fn f_overflowing_neg(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: (u64, bool) = u64::overflowing_neg(a0_conv);
        interp.data.push(Value::Boolean(r.1));
        interp.data.push(Value::Integer(r.0));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_shl(u64, u32) -> (u64, bool)`
fn f_overflowing_shl(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: (u64, bool) = u64::overflowing_shl(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `overflowing_shr(u64, u32) -> (u64, bool)`
fn f_overflowing_shr(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = u32::try_from(a1).map_err(|_| Error::IntegerOverflow)?;
            let r: (u64, bool) = u64::overflowing_shr(a0_conv, a1_conv);
            interp.data.push(Value::Boolean(r.1));
            interp.data.push(Value::Integer(r.0));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `div_euc(u64, u64) -> u64`
fn f_div_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::div_euc(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `mod_euc(u64, u64) -> u64`
fn f_mod_euc(interp: &mut Interpreter) -> Result<(), Error> {
    let arg1 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        if let Value::Integer(a1) = arg1 {
            let a0_conv = a0;
            let a1_conv = a1;
            let r: u64 = u64::mod_euc(a0_conv, a1_conv);
            interp.data.push(Value::Integer(r));
            Ok(())
        } else {
            Err(Error::WrongArgumentType(
                arg1.type_(),
                vec![ValueType::Integer],
            ))
        }
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `is_power_of_two(u64) -> bool`
fn f_is_power_of_two(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: bool = u64::is_power_of_two(a0_conv);
        interp.data.push(Value::Boolean(r));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `next_power_of_two(u64) -> u64`
fn f_next_power_of_two(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u64 = u64::next_power_of_two(a0_conv);
        interp.data.push(Value::Integer(r));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `checked_next_power_of_two(u64) -> Option<u64>`
fn f_checked_next_power_of_two(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: Option<u64> = u64::checked_next_power_of_two(a0_conv);
        if let Some(v) = r {
            interp.data.push(Value::Integer(v));
        }
        interp.data.push(Value::Boolean(r.is_some()));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

/// `wrapping_next_power_of_two(u64) -> u64`
fn f_wrapping_next_power_of_two(interp: &mut Interpreter) -> Result<(), Error> {
    let arg0 = interp.data.pop().ok_or(Error::StackUndeflow)?;
    if let Value::Integer(a0) = arg0 {
        let a0_conv = a0;
        let r: u64 = u64::wrapping_next_power_of_two(a0_conv);
        interp.data.push(Value::Integer(r));
        Ok(())
    } else {
        Err(Error::WrongArgumentType(
            arg0.type_(),
            vec![ValueType::Integer],
        ))
    }
}

pub fn register_all(interp: &mut Interpreter) {
    interp.register_builtin(BuiltinFunction::new("count_ones", f_count_ones));
    interp.register_builtin(BuiltinFunction::new("count_zeros", f_count_zeros));
    interp.register_builtin(BuiltinFunction::new("leading_zeros", f_leading_zeros));
    interp.register_builtin(BuiltinFunction::new("trailing_zeros", f_trailing_zeros));
    interp.register_builtin(BuiltinFunction::new("rotate_left", f_rotate_left));
    interp.register_builtin(BuiltinFunction::new("rotate_right", f_rotate_right));
    interp.register_builtin(BuiltinFunction::new("swap_bytes", f_swap_bytes));
    interp.register_builtin(BuiltinFunction::new("reverse_bits", f_reverse_bits));
    interp.register_builtin(BuiltinFunction::new("checked_add", f_checked_add));
    interp.register_builtin(BuiltinFunction::new("checked_sub", f_checked_sub));
    interp.register_builtin(BuiltinFunction::new("checked_mul", f_checked_mul));
    interp.register_builtin(BuiltinFunction::new("checked_div", f_checked_div));
    interp.register_builtin(BuiltinFunction::new("checked_div_euc", f_checked_div_euc));
    interp.register_builtin(BuiltinFunction::new("checked_rem", f_checked_rem));
    interp.register_builtin(BuiltinFunction::new("checked_mod_euc", f_checked_mod_euc));
    interp.register_builtin(BuiltinFunction::new("checked_neg", f_checked_neg));
    interp.register_builtin(BuiltinFunction::new("checked_shl", f_checked_shl));
    interp.register_builtin(BuiltinFunction::new("checked_shr", f_checked_shr));
    interp.register_builtin(BuiltinFunction::new("saturating_add", f_saturating_add));
    interp.register_builtin(BuiltinFunction::new("saturating_sub", f_saturating_sub));
    interp.register_builtin(BuiltinFunction::new("saturating_mul", f_saturating_mul));
    interp.register_builtin(BuiltinFunction::new("saturating_pow", f_saturating_pow));
    interp.register_builtin(BuiltinFunction::new("wrapping_add", f_wrapping_add));
    interp.register_builtin(BuiltinFunction::new("wrapping_sub", f_wrapping_sub));
    interp.register_builtin(BuiltinFunction::new("wrapping_mul", f_wrapping_mul));
    interp.register_builtin(BuiltinFunction::new("wrapping_div", f_wrapping_div));
    interp.register_builtin(BuiltinFunction::new("wrapping_div_euc", f_wrapping_div_euc));
    interp.register_builtin(BuiltinFunction::new("wrapping_rem", f_wrapping_rem));
    interp.register_builtin(BuiltinFunction::new("wrapping_mod_euc", f_wrapping_mod_euc));
    interp.register_builtin(BuiltinFunction::new("wrapping_neg", f_wrapping_neg));
    interp.register_builtin(BuiltinFunction::new("wrapping_shl", f_wrapping_shl));
    interp.register_builtin(BuiltinFunction::new("wrapping_shr", f_wrapping_shr));
    interp.register_builtin(BuiltinFunction::new("overflowing_add", f_overflowing_add));
    interp.register_builtin(BuiltinFunction::new("overflowing_sub", f_overflowing_sub));
    interp.register_builtin(BuiltinFunction::new("overflowing_mul", f_overflowing_mul));
    interp.register_builtin(BuiltinFunction::new("overflowing_div", f_overflowing_div));
    interp.register_builtin(BuiltinFunction::new(
        "overflowing_div_euc",
        f_overflowing_div_euc,
    ));
    interp.register_builtin(BuiltinFunction::new("overflowing_rem", f_overflowing_rem));
    interp.register_builtin(BuiltinFunction::new(
        "overflowing_mod_euc",
        f_overflowing_mod_euc,
    ));
    interp.register_builtin(BuiltinFunction::new("overflowing_neg", f_overflowing_neg));
    interp.register_builtin(BuiltinFunction::new("overflowing_shl", f_overflowing_shl));
    interp.register_builtin(BuiltinFunction::new("overflowing_shr", f_overflowing_shr));
    interp.register_builtin(BuiltinFunction::new("div_euc", f_div_euc));
    interp.register_builtin(BuiltinFunction::new("mod_euc", f_mod_euc));
    interp.register_builtin(BuiltinFunction::new("is_power_of_two", f_is_power_of_two));
    interp.register_builtin(BuiltinFunction::new(
        "next_power_of_two",
        f_next_power_of_two,
    ));
    interp.register_builtin(BuiltinFunction::new(
        "checked_next_power_of_two",
        f_checked_next_power_of_two,
    ));
    interp.register_builtin(BuiltinFunction::new(
        "wrapping_next_power_of_two",
        f_wrapping_next_power_of_two,
    ));
}
